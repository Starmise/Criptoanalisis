#pragma once
#include "Prerequisites.h"

/**
* @class CryptoGenerator
* @brief Generates cryptographically secure passwords, keys, IVs and salts, and provides encryption (hex/Base64) and memory cleaning utilities.
*/
class
  CryptoGenerator {
public:
  /**
  * @class Class constructor
  * @brief Initializes the Mersenne Twister engine with seed extracted from
  * std::random_device to guarantee cryptographic entropy.
  */
  CryptoGenerator() {
    std::random_device rd; // Random number generation device with high entropy.
    m_engine.seed(rd()); // Seed of the Mersenne Twister engine with the entropy of the device.
  }

  ~CryptoGenerator() = default;

  /**More actions
  * @brief Generates a random password.
  * @param length Length of the password to generate.
  * @param useUpper Include uppercase letters [A-Z].
  * @param useLower Include lowercase letters [a-z].
  * @param useDigits Include digits [0-9].
  * @param useSymbols Include special symbols.
  * @return std::string Generated password.
  * @throws std::runtime_error If no character type is enabled.
  */
  std::string
    generatePassword(unsigned int length,
      bool useUpper = true,
      bool useLower = true,
      bool useDigits = true,
      bool useSymbols = false) {
    const std::string uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const std::string lowers = "abcdefghijklmnopqrstuvwxyz";
    const std::string digits = "0123456789";
    const std::string symbols = "!@#$%^&*()-_=+[]{}|;:',.<>?/";

    std::string pool;
    if (useUpper) pool += uppers;
    if (useLower) pool += lowers;
    if (useDigits) pool += digits;
    if (useSymbols) pool += symbols;

    // Check if the pool is empty
    if (pool.empty()) {
      throw std::runtime_error("No character types enabled for password generation.");
    }

    std::uniform_int_distribution<unsigned int> dist(0, static_cast<unsigned int>(pool.size() - 1));
    std::string password;
    password.reserve(length); // Reserve space to avoid reallocations

    for (unsigned int i = 0; i < length; i++) {
      password += pool[dist(m_engine)]; // Selects a random character from the pool.
    }
    return password; // Returns the generated password
  }

  /*
  * @brief Generates a buffer of random bytes.
  * @param numBytes Number of bytes to be generated.
  * @return std::vector<uint8_t> Vector with values in [0x00-0xFF].
  */
  std::vector<uint8_t>
    generateBytes(unsigned int numBytes) {
    std::vector<uint8_t> bytes(numBytes);
    std::uniform_int_distribution<int> dist(0, 255); // Uniform distribution of the range [0x00-0xFF]. 

    for (unsigned int i = 0; i < numBytes; ++i) {
      bytes[i] = static_cast<uint8_t>(dist(m_engine)); // Asign a random byte to the vector.
    }
    return bytes; // Retuns the vector of generated bytes.
  }

  /*
  * @brief Converts bytes to a hexadecimal chain
  */
  std::string
    toHex(const std::vector<uint8_t>& data) {

    std::ostringstream oss;
    for (const auto& byte : data) {
      oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    return oss.str(); // Converts the vector of bytes to a hexadecimal chain
  }

  /*
  * @brief Decodes an hexadecimal chain to bytes
  */
  std::vector<uint8_t>
    fromHex(const std::string& hex) {
    if (hex.size() % 2 != 0) {
      throw std::runtime_error("Hex inválido (longitud impar).");
    }

    std::vector<uint8_t> data(hex.size() / 2);
    for (size_t i = 0; i < data.size(); ++i) {
      unsigned int byte;
      std::istringstream(hex.substr(2 * i, 2)) >> std::hex >> byte;
      data[i] = static_cast<uint8_t>(byte);
    }
    return data;
  }

  /*
  * @brief Generate a simetric key of a given size in bits.
  * @param bits Size of the key in bits (must be a multiple of 8)
  * @return std::vector<uint8_t> Key generated (bits/8 bytes)
  * @throws std::runtime_error If bits isnt a multiple of 8.
  */
  std::vector<uint8_t>
    generateKey(unsigned int bits) {
    if (bits % 8 != 0) {
      throw std::runtime_error("Bits debe ser múltiplo de 8.");
    }
    return generateBytes(bits / 8);
  }

  /**
    * @brief Generates an initialization vector (IV) of given size in bytes.
    * An IV is a random value used in symmetric encryption modes (CBC, CFB, GCM...) }
    * to ensure that the same key encrypts identical messages on different outputs.
    *
    * @param blockSize Size of the IV in bytes.
    * @return std::vector<uint8_t> IV generated.
    */
  std::vector<uint8_t>
    generateIV(unsigned int blockSize) {
    return generateBytes(blockSize);
  }

  /*
  * @brief Generate a cryptographic salt of a given lenght.
  * A salt is a random value that is combined with the password when deriving a key
  * (e.g., in PBKDF2, scrypt, Argon2) to prevent rainbow table attacks and ensure
  * that each derivation is unique. Salt is used to “thicken” the entropy of
  * passwords when deriving keys.
  *
  * @param lenght Lenght of the salt in bytes.
  * @return std::vector<uint8_t> Generated Salt.
  */
  std::vector<uint8_t>
    generateSalt(unsigned int length) {
    return generateBytes(length);
  }

  /*
  * @brief Converts a byte vector to a Base64 string.
  * @param data Input byte vector.
  * @return std::string Base64 representation (with padding ‘=’ if applicable)
  */
  std::string
    toBase64(const std::vector<uint8_t>& data) {
    static const char* table =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      "abcdefghijklmnopqrstuvwxyz"
      "0123456789+/";
    std::string b64;
    unsigned int i = 0;

    // Process blocks of 3 bytes. We take 3 bytes and concatenate them into a 24-bit integer.
    // That integer is divided into four "six bits" (24 / 6 = 4).
    // Each group of 6 bits (value 0-63) is used as an index in the table to obtain a character.
    while (i + 2 < data.size()) {
      unsigned int block = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2];
      b64 += table[(block >> 18) & 0x3F];
      b64 += table[(block >> 12) & 0x3F];
      b64 += table[(block >> 6) & 0x3F];
      b64 += table[(block) & 0x3F];
      i += 3;
    }

    // Process the last 1 or 2 remaining bytes, adding padding ‘=’ if necessary.
    if (i < data.size()) {
      uint32_t block = data[i] << 16;
      b64 += table[(block >> 18) & 0x3F];
      if (i + 1 < data.size()) {
        block = data[i + 1] << 8;
        b64 += table[(block >> 12) & 0x3F];
        b64 += table[(block >> 6) & 0x3F];
        b64 += '=';
      }
      else {
        b64 += table[(block >> 12) & 0x3F];
        b64 += '==';
      }
    }
    return b64; // Returns the Base64 string generated.
  }

private:
  std::mt19937 m_engine; ///< Mersenne Twister random number generation engine.
};