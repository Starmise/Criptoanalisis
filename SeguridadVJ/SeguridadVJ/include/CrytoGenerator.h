#pragma once
#include "Prerequisites.h"

/**
* @class CryptoGenerator
* @brief Generates cryptographically secure passwords, keys, IVs and salts, and provides encryption (hex/Base64) and memory cleaning utilities.
*/
class
  CryptoGenerator {
public:
  /**
  * @class Class constructor
  * @brief Initializes the Mersenne Twister engine with seed extracted from
  * std::random_device to guarantee cryptographic entropy.
  */
  CryptoGenerator() {
    std::random_device rd; // Random number generation device with high entropy.
    m_engine.seed(rd()); // Seed of the Mersenne Twister engine with the entropy of the device.
  }

  ~CryptoGenerator() = default;

  /**More actions
  * @brief Generates a random password.
  * @param length Length of the password to generate.
  * @param useUpper Include uppercase letters [A-Z].
  * @param useLower Include lowercase letters [a-z].
  * @param useDigits Include digits [0-9].
  * @param useSymbols Include special symbols.
  * @return std::string Generated password.
  * @throws std::runtime_error If no character type is enabled.
  */
  std::string
    generatePassword(unsigned int length,
      bool useUpper = true,
      bool useLower = true,
      bool useDigits = true,
      bool useSymbols = false) {
    const std::string uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const std::string lowers = "abcdefghijklmnopqrstuvwxyz";
    const std::string digits = "0123456789";
    const std::string symbols = "!@#$%^&*()-_=+[]{}|;:',.<>?/";

    std::string pool;
    if (useUpper) pool += uppers;
    if (useLower) pool += lowers;
    if (useDigits) pool += digits;
    if (useSymbols) pool += symbols;

    // Check if the pool is empty
    if (pool.empty()) {
      throw std::runtime_error("No character types enabled for password generation.");
    }

    std::uniform_int_distribution<unsigned int> dist(0, static_cast<unsigned int>(pool.size() - 1));
    std::string password;
    password.reserve(length); // Reserve space to avoid reallocations

    for (unsigned int i = 0; i < length; i++) {
      password += pool[dist(m_engine)]; // Selects a random character from the pool.
    }
    return password; // Returns the generated password
  }

  /*
  * @brief Generates a buffer of random bytes.
  * @param numBytes Number of bytes to be generated.
  * @return std::vector<uint8_t> Vector with values in [0x00-0xFF].
  */
  std::vector<uint8_t>
    generateBytes(unsigned int numBytes) {
    std::vector<uint8_t> bytes(numBytes);
    std::uniform_int_distribution<int> dist(0, 255); // Uniform distribution of the range [0x00-0xFF]. 

    for (unsigned int i = 0; i < numBytes; ++i) {
      bytes[i] = static_cast<uint8_t>(dist(m_engine)); // Asign a random byte to the vector.
    }
    return bytes; // Retuns the vector of generated bytes.
  }

  /*
  * @brief Converts bytes to a hexadecimal chain
  */
  std::string
    toHex(const std::vector<uint8_t>& data) {

    std::ostringstream oss;
    for (const auto& byte : data) {
      oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    return oss.str(); // Converts the vector of bytes to a hexadecimal chain
  }

  /*
  * @brief Decodes an hexadecimal chain to bytes
  */
  std::vector<uint8_t>
    fromHex(const std::string& hex) {
    if (hex.size() % 2 != 0) {
      throw std::runtime_error("Hex inválido (longitud impar).");
    }

    std::vector<uint8_t> data(hex.size() / 2);
    for (size_t i = 0; i < data.size(); ++i) {
      unsigned int byte;
      std::istringstream(hex.substr(2 * i, 2)) >> std::hex >> byte;
      data[i] = static_cast<uint8_t>(byte);
    }
    return data;
  }

  /*
  * @brief Generate a simetric key of a given size in bits.
  * @param bits Size of the key in bits (must be a multiple of 8)
  * @return std::vector<uint8_t> Key generated (bits/8 bytes)
  * @throws std::runtime_error If bits isnt a multiple of 8.
  */
  std::vector<uint8_t>
    generateKey(unsigned int bits) {
    if (bits % 8 != 0) {
      throw std::runtime_error("Bits debe ser múltiplo de 8.");
    }
    return generateBytes(bits / 8);
  }

  /**
    * @brief Generates an initialization vector (IV) of given size in bytes.
    * An IV is a random value used in symmetric encryption modes (CBC, CFB, GCM...) }
    * to ensure that the same key encrypts identical messages on different outputs.
    *
    * @param blockSize Size of the IV in bytes.
    * @return std::vector<uint8_t> IV generated.
    */
  std::vector<uint8_t>
    generateIV(unsigned int blockSize) {
    return generateBytes(blockSize);
  }

  /*
  * @brief Generate a cryptographic salt of a given lenght.
  * A salt is a random value that is combined with the password when deriving a key
  * (e.g., in PBKDF2, scrypt, Argon2) to prevent rainbow table attacks and ensure
  * that each derivation is unique. Salt is used to “thicken” the entropy of
  * passwords when deriving keys.
  *
  * @param lenght Lenght of the salt in bytes.
  * @return std::vector<uint8_t> Generated Salt.
  */
  std::vector<uint8_t>
    generateSalt(unsigned int length) {
    return generateBytes(length);
  }

  /*
  * @brief Converts a byte vector to a Base64 string.
  * @param data Input byte vector.
  * @return std::string Base64 representation (with padding ‘=’ if applicable)
  */
  std::string
    toBase64(const std::vector<uint8_t>& data) {
    static const char* table =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      "abcdefghijklmnopqrstuvwxyz"
      "0123456789+/";
    std::string b64;
    unsigned int i = 0;

    // Process blocks of 3 bytes. We take 3 bytes and concatenate them into a 24-bit integer.
    // That integer is divided into four "six bits" (24 / 6 = 4).
    // Each group of 6 bits (value 0-63) is used as an index in the table to obtain a character.
    while (i + 2 < data.size()) {
      unsigned int block = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2];
      b64 += table[(block >> 18) & 0x3F];
      b64 += table[(block >> 12) & 0x3F];
      b64 += table[(block >> 6) & 0x3F];
      b64 += table[(block) & 0x3F];
      i += 3;
    }

    // Process the last 1 or 2 remaining bytes, adding padding ‘=’ if necessary.
    if (i < data.size()) {
      uint32_t block = data[i] << 16;
      b64 += table[(block >> 18) & 0x3F];
      if (i + 1 < data.size()) {
        block = data[i + 1] << 8;
        b64 += table[(block >> 12) & 0x3F];
        b64 += table[(block >> 6) & 0x3F];
        b64 += '=';
      }
      else {
        b64 += table[(block >> 12) & 0x3F];
        b64 += '==';
      }
    }
    return b64; // Returns the Base64 string generated.
  }

  /*
  * @brief Decode a standar Base64 string in bytes.
  * @param b64 String Base64
  * @return std::vector<uint8_t> Decoded bytes
  * @throws std::runtime_error If the string isn't a valid Base64
  */
  std::vector<uint8_t>
    fromBase64(const std::string& b64) {
    std::lock_guard<std::mutex> lock(_mtx);
    std::vector<uint8_t> out;
    size_t len = b64.size();
    size_t pad = 0;

    if (len >= 1 && b64[len - 1] == '=') pad++;
    if (len >= 2 && b64[len - 2] == '=') pad++;
    out.reserve(((len / 4) * 3) - pad);

    unsigned int i = 0;
    while (i < len) {
      uint32_t block = 0;
      unsigned int chars = 0;
      for (unsigned int j = 0; j < 4 && i < len; ++j, ++i) {
        uint8_t v = _decTable[(unsigned char)b64[i]];
        if (v == 0xFF) { j--; continue; }
        block = (block << 6) | v; // Shifts the block and adds the value of the character
        ++chars;
      }
      for (unsigned int k = 0; k < chars - 1; ++k) {
        out.push_back((block >> (8 * (chars - 2 - k))) & 0xff);
      }
    }
    return out;
  }

  /*
  * @brief Clean in a safe form the sensible data of the vector.
  * Overrides each byte with zero to avoid memory leaks.
  * @param data Vector which elements will be cleaned.
  */
  void
    secureWipe(std::vector<uint8_t>& data) {
    std::fill(data.begin(), data.end(), 0);
  }

  /*
  * @brief Validates if a password complies with minimum policies.
  * Requires at least one uppercase, one lowercase and one number.
  * @param password Password to validate
  * @return true if it complies the policy, false if not.
  */
  bool
    validatePassword(const std::string& password) {
    if (password.size() < 8) return false;

    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbols = false;

    for (char c : password) {
      if (std::isupper((unsigned char)c)) {
        hasUpper = true;
      }
      else if (std::islower((unsigned char)c)) {
        hasLower = true;
      }
      else if (std::isdigit((unsigned char)c)) {
        hasDigit = true;
      }
      else if (std::ispunct((unsigned char)c)) {
        hasSymbols = true;
      }
    }
    return hasUpper && hasLower && hasDigit && hasSymbols;
  }

  /*
  * @brief Estimates the approximate password entropy in bits,
  * based on the size of the character pool used and the length.
  * @param password Password to evaluate
  * @return Estimated entropy bits
  */
  double
    estimateEntropy(const std::string& password) {
    if (password.size() < 8) return 0.0;

    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbols = false;
    for (char c : password) {
      if (std::isupper((unsigned char)c)) {
        hasUpper = true;
      }
      else if (std::islower((unsigned char)c)) {
        hasLower = true;
      }
      else if (std::isdigit((unsigned char)c)) {
        hasDigit = true;
      }
      else if (std::ispunct((unsigned char)c)) {
        hasSymbols = true;
      }
    }

    unsigned int poolSize = 0;
    if (hasLower) {
      poolSize += 26; // 26 lowercase letters.
    }
    if (hasUpper) {
      poolSize += 26; // 26 uppercase letters.
    }
    if (hasDigit) {
      poolSize += 10; // 10 digits (0-9).
    }
    if (hasSymbols) {
      poolSize += 32; // Approximately 32 common symbols
    }
    if (poolSize == 0) {
      std::cout << "No character types enabled for entropy estimation." << std::endl;
      return 0.0; // If there are no valid characters, entropy is 0.
    }

    double entropy = std::log2(static_cast<double>(poolSize)) * password.size(); // Entropy = log2(poolSize) * lenght.
    return entropy;
  }

  /*
  * @brief Estimates the approximate password entropy in bits,
  * based on the size of the character pool used and the length.
  * @param password Password to evaluate
  * @return Estimated entropy bits
  */
  std::string
    passwordStrength(const std::string& password) {
    double entropy = estimateEntropy(password);
    if (entropy < 28) {
      return "Very weak"; // Entropy < 28 bits.
    }
    else if (entropy < 40) {
      return "Weak"; // Entropy between 28 and 40 bits.
    }
    else if (entropy < 60) {
      return "Moderate"; // Entropy between 48 and 68 bits.
    }
    else if (entropy < 80) {
      return "Strong"; // Entropy between 60 and 88 bits.
    }
    else {
      return "Very strong"; // Entropy >= 80 bits.
    }
  }

  /*
  * @brief Method that generates a given number of passwords and
  * returns only the passwords with the highest possible entropy.
  * @param count
  * @param length Length of the password to generate.
  * @param useUpper Include uppercase letters [A-Z].
  * @param useLower Include lowercase letters [a-z].
  * @param useDigits Include digits [0-9].
  * @param useSymbols Include special symbols.
  * @return std::vector<std::string> Best 3 passwords with the highest entriopy.
  */
  std::vector<std::string>
    Best3ByEntropy(unsigned int count,
      unsigned int lenght = 16,
      bool useUpper = true,
      bool useLower = true,
      bool useDigits = true,
      bool useSymbols = false) {
    if (count < 3) {
      throw std::invalid_argument("It is needed at least 3 passwords to be generated");
    }

    std::vector<std::string> generatedPasswords;
    std::vector<double> entropies;

    // Produces a random integer values i, uniformly distributed on the closed interval [a, b].
    std::uniform_int_distribution<int> boolDist(0, 1);

    for (unsigned int i = 0; i < count; i++) {
      // Random params for each configuration of the password.
      bool useUpper = boolDist(m_engine);
      bool useLower = boolDist(m_engine);
      bool useDigits = boolDist(m_engine);
      bool useSymbols = boolDist(m_engine);

      if (!useUpper && !useLower && !useDigits && !useSymbols) {
        useLower = true; // If nothing is true, then lower-case will be true.
      }

      std::string paswordd = generatePassword(lenght, useUpper, useLower, useDigits, useSymbols);
      double aproxEntropy = estimateEntropy(paswordd);
      generatedPasswords.push_back(paswordd);
      entropies.push_back(aproxEntropy);
    }

    std::vector<std::string> top3pass;
    for (int i = 0; i < 3; i++) {
      double maxEntropy = 0.0;
      int maxIndex = -1;

      for (unsigned int j = 0; j < entropies.size(); ++j) {
        if (entropies[j] > maxEntropy) {
          maxEntropy = entropies[j];
          maxIndex = j;
        }
      }

      if (maxIndex != -1) {
        top3pass.push_back(generatedPasswords[maxIndex]);

        std::cout << "Best Password " << (i+1) <<  ": " << generatedPasswords[maxIndex] << std::endl;
        std::cout << "Entropy: " << entropies[maxIndex] << std::endl;
        std::cout << "\n";
        
        entropies[maxIndex] = -1.0;
      }
    }
    return top3pass;
  }

private:
  std::mt19937 m_engine; ///< Mersenne Twister random number generation engine.
  std::mutex _mtx;
  std::array<uint8_t, 256>_decTable;
};